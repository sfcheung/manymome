% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cond_indirect.R
\name{cond_indirect}
\alias{cond_indirect}
\alias{cond_indirect_effects}
\alias{indirect_effect}
\title{Conditional, Indirect, and Conditional Indirect Effects}
\usage{
cond_indirect(
  x,
  y,
  m = NULL,
  fit = NULL,
  est = NULL,
  implied_stats = NULL,
  wvalues = NULL,
  standardized_x = FALSE,
  standardized_y = FALSE,
  boot_ci = FALSE,
  level = 0.95,
  boot_out = NULL,
  R = 100,
  seed = NULL,
  save_boot_full = FALSE,
  prods = NULL,
  get_prods_only = FALSE
)

cond_indirect_effects(
  wlevels,
  ...,
  fit = fit,
  boot_ci = FALSE,
  boot_out = NULL,
  R = 100,
  seed = NULL,
  output_type = "data.frame"
)

indirect_effect(
  x,
  y,
  m = NULL,
  fit = NULL,
  est = NULL,
  implied_stats = NULL,
  standardized_x = FALSE,
  standardized_y = FALSE,
  boot_ci = FALSE,
  level = 0.95,
  boot_out = NULL,
  R = 100,
  seed = NULL,
  save_boot_full = FALSE
)
}
\arguments{
\item{x}{Character. The name of predictor at the start of the
pathway.}

\item{y}{Character. The name of the outcome variable at the end of
the pathway.}

\item{m}{A vector of the variable names of the moderators. The
pathway goes from the first mediator successively to the last
mediator. If \code{NULL}, the default, the pathway goes from \code{x} to
\code{y}.}

\item{fit}{The fit object. Can be a
\link[lavaan:lavaan-class]{lavaan::lavaan} object or a list of \code{\link[=lm]{lm()}} outputs.}

\item{est}{The output of \code{\link[lavaan:parameterEstimates]{lavaan::parameterEstimates()}}. If \code{NULL},
the default, it will be generated from \code{fit}. If supplied, \code{fit}
will ge ignored.}

\item{implied_stats}{Implied means, variances, and covariances of
observed variables, of the form of the output of
\code{\link[lavaan:lavInspect]{lavaan::lavInspect()}} with \code{what} set to \code{"implied"}. The
standard deviations are extracted from this object for
standardization. Default is \code{NULL}, and implied statistics will
be computed from \code{fit} if required.}

\item{wvalues}{A numeric vector of named elements. The names are
the variable names of the moderators, and the values are the
values to which the moderators will be set to. Default is
\code{NULL}.}

\item{standardized_x}{Logical. Whether \code{x} will be standardized.
Default is \code{FALSE}.}

\item{standardized_y}{Logical. Whether \code{y} will be standardized.
Default is \code{FALSE}.}

\item{boot_ci}{Logical. Whether bootstrap confidence interval will
be formed. Default is \code{FALSE}.}

\item{level}{The level of confidence for the bootstrap confidence
interval. Default is .95.}

\item{boot_out}{If \code{boot_ci} is \code{TRUE}, users can supply
pregenerated bootstrap results. This can be the output of
\code{\link[=fit2boot_out]{fit2boot_out()}} or \code{\link[=lm2boot_out]{lm2boot_out()}}. If not supplied, the
function will try to generate them from \code{fit}.}

\item{R}{Integer. If \code{boot_ci} is \code{TRUE}, \code{fit} is a list of \code{\link[=lm]{lm()}}
outputs, and \code{boot_out} is \code{NULL}, this function will do
bootstrapping on \code{fit}. \code{R} is the number of bootstrap samples.
Default is 100.}

\item{seed}{If \code{boot_ci} is \code{TRUE}, \code{fit} is a list of \code{\link[=lm]{lm()}}
outputs, and \code{boot_out} is \code{NULL}, this function will do
bootstrapping on \code{fit}. This is the seed for the bootstrapping.
Default is \code{NULL} and seed is not set.}

\item{save_boot_full}{If \code{TRUE}, full bootstrapping results will be
stored. Default is \code{FALSE.}}

\item{prods}{The product terms found. For internal use.}

\item{get_prods_only}{IF \code{TRUE}, will quit early and return the product
terms found. The results can be passed to the \code{prod} argument
when calling this function. Default is \code{FALSE}.}

\item{wlevels}{The output of \code{\link[=merge_mod_levels]{merge_mod_levels()}}.}

\item{...}{Arguments to be passed to \code{\link[=cond_indirect]{cond_indirect()}}}

\item{output_type}{The type of output of \code{\link[=cond_indirect_effects]{cond_indirect_effects()}}.
If \code{"data.frame"}, the default, the output will be converted to
a data frame. If any other value, the output is a list of the
outputs from \code{\link[=cond_indirect]{cond_indirect()}}.}
}
\value{
\code{\link[=cond_indirect]{cond_indirect()}} returns an \code{indirect}-class object.

\code{\link[=cond_indirect_effects]{cond_indirect_effects()}} returns a \code{cond_indirect_effects}-class
object.

These two classes of objects their own print methods for printing
the results (see \code{\link[=print.indirect]{print.indirect()}} and
\code{\link[=print.cond_indirect_effects]{print.cond_indirect_effects()}})
}
\description{
Compute the conditional effects, indirect effects, or
conditional indirect effects in a structural model fitted by
\code{\link[=lm]{lm()}} or \code{\link[lavaan:lavaan]{lavaan::lavaan()}}.
}
\details{
For a model with a mediation pathway moderated by one or more
moderators, \code{\link[=cond_indirect]{cond_indirect()}} and \code{\link[=cond_indirect_effects]{cond_indirect_effects()}} can be
used to compute the conditional indirect effect from one variable
to another variable, at selected level(s) of the moderator(s).

If only the mediator(s) is/are specified (\code{m}) and no values of
moderator(s) are specified, then the indirect effect from one
variable (\code{x}) to another variable (\code{y}) is computed.

If only the value(s) of moderator(s) is/are specified (\code{wvalues} or
\code{wlevels}) and no mediators (\code{m}) are specified, then the
conditional direct effects from one variable to another are
computed.
}
\section{Functions}{
\itemize{
\item \code{cond_indirect}: Compute conditional, indirect, or
conditional indirect effects for one set
of levels.

\item \code{cond_indirect_effects}: Compute the conditional, indirect, or
conditional indirect effects for several
sets of levels.

\item \code{indirect_effect}: Compute the indirect effects. A wrapper of
\code{\link[=cond_indirect]{cond_indirect()}}. Can be used
when there is no moderator.
}}

\examples{

library(lavaan)
dat <- modmed_x1m3w4y1
mod <-
"
m1 ~ a1 * x  + d1 * w1 + e1 * x:w1
m2 ~ a2 * x
y  ~ b1 * m1 + b2 * m2 + cp * x
"
fit <- sem(mod, dat, meanstructure = TRUE, fixed.x = FALSE, se = "none", baseline = FALSE)
est <- parameterEstimates(fit)
hi_w1 <- mean(dat$w1) + sd(dat$w1)

# Examples for cond_indirect():

# Conditional effect from x to m1 when w1 is 1 SD above mean
cond_indirect(x = "x", y = "m1",
              wvalues = c(w1 = hi_w1), fit = fit)

# Indirect effect from x1 through m2 to y
cond_indirect(x = "x", y = "y", m = "m2", fit = fit)

# Conditional Indirect effect from x1 through m1 to y, when w1 is 1 SD above mean
cond_indirect(x = "x", y = "y", m = "m1",
              wvalues = c(w1 = hi_w1), fit = fit)



# Examples for cond_indirect_effects():

# Create levels of w1, the moderators
w1levels <- mod_levels("w1", fit = fit)
w1levels

# Conditional effects from x to m1 when w1 is equal to each of the levels
cond_indirect_effects(x = "x", y = "m1",
                      wlevels = w1levels, fit = fit)

# Conditional Indirect effect from x1 through m1 to y,
# when w1 is equal to each of the levels
cond_indirect_effects(x = "x", y = "y", m = "m1",
                      wlevels = w1levels, fit = fit)

}
\author{
Shu Fai Cheung \url{https://orcid.org/0000-0002-9871-9448}
}
