---
title: "manymome"
author: "Shu Fai Cheung"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{manymome}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
if (basename(getwd()) == "manymome") {
    pth <- "./vignettes/"
  } else {
    pth <- "./"
  }
```

# Introduction

This article is a brief illustration on how `manymome` functions are
used in some typical cases. The model is intended to be
simple for illustration but complicated enough to
show the flexibility of `manymome`.

# Moderated Mediation by SEM using `lavaan`

This is the sample dataset comes with the package:

```{r}
library(manymome)
dat <- data_med_mod_ab
print(head(dat), digits = 3)
```

Suppose this is the model being fitted:

```{r echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
dat$xw1 <- dat$x * dat$w1
dat$mw2 <- dat$m * dat$w2
mod <-
"
xw1 ~ x + w1
m ~ xw1
mw2 ~ m + w2
y ~ mw2
y ~ x
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c("w1", NA, NA, NA, "w2",
                   NA, NA, "m", NA, NA,
                   NA, "xw1", NA, "mw2", NA,
                   "x", NA, NA, NA, "y"), 4, 5, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 10,
              DoNotPlot = TRUE)
p$graphAttributes$Nodes$width[c(1, 3)] <- .01
p$graphAttributes$Nodes$height[c(1, 3)] <- .01
p$graphAttributes$Edges$asize[c(1, 4)] <- 0
plot(p)
```

## Fitting the Model

This is a moderated mediation model with

  - a mediation path `x -> m -> y`, and

  - two moderators: `x -> m` moderated by `w1` and `m -> y` moderated by `w2`.

The effects of interest are the *conditional
indirect effects*: the indirect effects from `x` to `y` through `m` for
different levels of `w1` and `w2`.

The effects in this moderated mediation model can be
estimated by SEM in R using
`lavaan::sem()`.

```{r}
library(lavaan)
dat$w1x <- dat$w1 * dat$x
dat$w2m <- dat$w2 * dat$m
mod <-
"
m ~ x + w1 + w1x
y ~ m + w2 + w2m + x
# Covariance between w2m and the error term of m
w2m ~~ m
# Covariance between w2m and the error term of m
w2m ~~ w2 + x + w1 + w1x
w2  ~~ x + w1 + w1x
x   ~~ w1 + w1x
w1  ~~ w1x
"
fit <- sem(model = mod,
           data = dat,
           fixed.x = FALSE,
           estimator = "MLR")
```

`MLR` is used to take into account probable nonnormality
due to the product terms and allowing the predictors to
be random variables (`fixed.x = FALSE`), which is more
natural in disciplines like social sciences.

These are the parameter estimates:

```{r}
parameterEstimates(fit)[parameterEstimates(fit)$op == "~", ]
```

Both moderation effects are significant. Because the indirect effect
is moderated on both stages (`x -> m` and `m -> y`), the magnitude
of the indirect effect depends on `w1` and `w2`. The indirect
effect conditional on the moderators is called the *conditional*
*indirect* *effect*. Moreover, like a mediation effect without moderation,
its confidence interval can be formed by nonparametric bootstrapping.

## Conditional Indirect Effects

Conventionally, to compute the conditional indirect effects,
we need to define user parameters, and we need to decide in advance
the levels of the moderators. If standardized conditional
indirect effect is needed, then the syntax will be much more complicated
even in this model because the variance of `y` is not a free parameter
and needs to be computed from (many) other parameters.

Using `manymome`, no need to label any coefficients or define any
user parameters, and also no need to request bootstrapping when
calling `lavaan::sem()`. It has functions that (a) generate bootstrap
estimates and this only need to be done once, and (b) compute
the conditional indirect effects for any levels of the moderators
along any path.

### Do Bootstrapping (Once)

The function `do_boot()` can be used to generate and store bootstrap
estimates as well as implied variances and SDs of variables:

```{r}
fit_boot <- do_boot(fit = fit,
                    R = 100,
                    seed = 53253)
```

The minium argument is `fit`, the output of `lavaan::sem()`.
`R` is the number of bootstrap samples, which should be 2000
or even 5000 in real research. `R` is set to 100 here just
for illustration. The `seed` is to make the results
reproducible. By default, parallel processing is used,
and so the results are reproducible only if the number of
processes is the same. See the help of `do_boot()` for
other options.

The output, `fit_boot` in this case, can then be used for
all subsequent analyses on this model.

### Estimating Conditional Indirect Effects

To compute conditional indirect effects and form bootstrap confidence
intervals, we can use `cond_indirect_effects()`.

```{r}
out_cond <- cond_indirect_effects(wlevels =c("w1", "w2"),
                                  x = "x",
                                  y = "y",
                                  m = "m",
                                  fit = fit,
                                  boot_ci = TRUE,
                                  boot_out = fit_boot)
```

These are the major arguments:

- `wlevels`: The vector of the names of the moderators.
- `x`: The name of the predictor.
- `y`: The name of the outcome variable.
- `m`: The name of the mediator, or a vector of names
       if the path has more than one mediator.
- `fit`: The output of `lavaan::sem()`.
- `boot_ci`: Set to `TRUE` to request bootstrap confidence intervals.
             Default is `FALSE`.
- `boot_out`: The pregenerated bootstrap estimates generated
              by `do_boot()` or previous call to
              `cond_indirect_effects()`.

This is the output:

```{r}
out_cond
```

For two or more moderators, the default levels for numeric moderators
are one standard deviation below mean and one standard deviation above
mean. For two moderators, there are four combinations. As shown
above, among these levels, the indirect effect from `x` to `y` through
`m` is significant only when both `w1` and `w2` are one standard deviation
above mean. The indirect effect at these levels of `w1` and `w2` are
`r formatC(coef(out_cond)[1], digits = 3, format = "f")`, with
95% bootstrap confidence interval
[`r paste0(formatC(unlist(confint(out_cond)[1, ]), digits = 3, format = "f"), collapse = ", ")`].

The levels of the moderators, `w1` and `w2` in this example, can be
controlled directly by users. See `mod_levels()` and `merge_mod_levels()`
on how to specify other levels of the moderators. Because `boot_out`
use pregenerated bootstrap estimates, changing the levels of the moderators
does not require doing bootstrapping again.

## Standardized Conditional Indirect Effects

To compute the standardized conditional indirect effects, we can
standardize
only the predictor (`x`), only the outcome (`y`), or both.

To standardize `x`, set `standardized_x` to `TRUE`. To standardize
`y`, set `standardized_y` to `TRUE`. To standardize both,
set both `standardized_x` and `standardized_y` to `TRUE`.

This is the result when both `x` and `y` are standardized:

```{r}
out_cond_stdxy <- cond_indirect_effects(wlevels =c("w1", "w2"),
                                        x = "x",
                                        y = "y",
                                        m = "m",
                                        fit = fit,
                                        boot_ci = TRUE,
                                        boot_out = fit_boot,
                                        standardized_x = TRUE,
                                        standardized_y = TRUE)
```

Note that `fit_boot` is used again, so that there is no need to
do bootstrapping again.

This is the output:

```{r}
out_cond_stdxy
```

The standardized indirect effect when both `w1` and `w2` are
one standard deviation above mean is
`r formatC(coef(out_cond_stdxy)[1], digits = 3, format = "f")`, with
95% bootstrap confidence interval
[`r paste0(formatC(unlist(confint(out_cond_stdxy)[1, ]), digits = 3, format = "f"), collapse = ", ")`].

## Index of Moderated Moderated Mediation

The index of moderated moderated mediation (Hayes, 2018) can
be estimated, along with bootstrap confidence interval, using
the function `index_of_momome()`:

```{r}
out_momome <- index_of_momome(x = "x",
                              y = "y",
                              m = "m",
                              w = "w1",
                              z = "w2",
                              fit = fit,
                              boot_ci = TRUE,
                              boot_out = fit_boot)
```

Again, setting `boot_out` to pregenerated bootstrap estimates
save the time for bootstrapping.

This is the result:

```{r}
out_momome
```

The index of moderated moderated mediation is
`r formatC(coef(out_momome), digits = 3, format = "f")`,
with 95% bootstrap confidence interval
[`r paste0(formatC(unlist(confint(out_momome)[1, ]), digits = 3, format = "f"), collapse = ", ")`].
Although `w1` and `w2` significantly moderate the component paths,
they do not significantly moderate the moderating effect of each Other
on the indirect effect.

# Mediation Only

The package can also be used for a mediation model.

This is the sample dataset comes with the package:

```{r}
library(manymome)
dat <- data_serial
print(head(dat), digits = 3)
```

Suppose this is the model being fitted, with `c1` and
`c2` the control variables.

```{r echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
mod <-
"m1 ~ x + c1 + c2
m2 ~ m1 + x + c1 + c2
y ~ m2 + m1 + x + c1 + c2
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c(NA, "m1", "m2", NA,
                     "x", NA, NA, "y",
                     "c1", NA, NA, NA,
                     "c2", NA, NA, NA), 4, 4, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 5,
              DoNotPlot = TRUE)
plot(p)
```

## Fitting the Model

Fitting this model in `lavaan::sem()` is very simple:

```{r}
mod_med <- "
m1 ~ x + c1 + c2
m2 ~ m1 + x + c1 + c2
y ~ m2 + m1 + x + c1 + c2
"
fit_med <- sem(model = mod_med,
               data = dat,
               fixed.x = TRUE)
```
These are the estimates

```{r}
parameterEstimates(fit_med)[parameterEstimates(fit_med)$op == "~", ]
```

## Estimating Indirect Effects

`indirect_effect()` can be used to estimate the indirect effect
and form its bootstrapping confidence interval along a path
in a model
that starts with any variable (predictor), ends with
any variable (outcome variable), through any variable(s) (mediator(s)).

Unlike the previous example, we illustrate how to
generate bootstrap estimates when calling `indirect_effect()`
instead of using `do_boot()`.

For example, this is the call for the indirect effect
from `x` to `y` through `m1` and `m2`:

```{r}
out_med <- indirect_effect(x = "x",
                           y = "y",
                           m = c("m1", "m2"),
                           fit = fit_med,
                           boot_ci = TRUE,
                           R = 100,
                           seed = 43143)
```

The main arguments are:

- `x`: The name of the predictor. The start of the path.
- `y`: The name of the outcome variable. The end of the path
- `m`: The name of the mediator, or the vector of names of the
        mediators if the path has more than one mediator,
        as in this example. The path moves from the first
        mediator to the last mediator. In this example,
        the correct order is `c("m1", "m2")`.
- `fit`: The output of `lavaan::sem()`.
- `boot_ci`: Set to `TRUE` to request bootstrapping confidence intervals.
             Default is `FALSE`.
- `R`: The number of bootstrap samples. Only 500 bootstrap samples
        for illustration. Set `R` to 2000 or even 5000 in real research.
- `seed`: The seed for the random number generator.

This is the output:

```{r}
out_med
```

The indirect effect from `x` to `y` through `m1` and `m2`
is `r formatC(coef(out_med), digits = 3, format = "f")`,
with a 95% confidence interval of
[`r paste0(formatC(confint(out_med), digits = 3, format = "f"), collapse = ", ")`],
significantly different from zero (*p* < .05).

Because bootstrap confidence interval is requested, the
bootstrap estimates are stored in `out_med` and so it
can also be used in the argument `boot_out`.

## Standardized Indirect Effect

To compute the indirect effect with the predictor standardized,
set `standardized_x` to `TRUE`. To compute the indirect effect
with the outcome variable standardized, set `standardized_y`
to `TRUE`. To compute the (completely) standardized
indirect effect, set both `standardized_x` and
`standardized_y` to `TRUE`.

This is the call to compute the (completely) standardized
indirect effect:

```{r}
out_med_stdxy <- indirect_effect(x = "x",
                                 y = "y",
                                 m = c("m1", "m2"),
                                 fit = fit_med,
                                 boot_ci = TRUE,
                                 boot_out = out_med,
                                 standardized_x = TRUE,
                                 standardized_y = TRUE)
out_med_stdxy
```

The indirect effect from `x` to `y` through `m1` and `m2`
is `r formatC(coef(out_med_stdxy), digits = 3, format = "f")`,
with a 95% confidence interval of
[`r paste0(formatC(confint(out_med_stdxy), digits = 3, format = "f"), collapse = ", ")`],
significantly different from zero (*p* < .05).

## Estimating Indirect Effects For *Any* Paths

`indirect_effect()` can be used for the indirect effect
in any path in a path model. There is no need to specify
the path when specifying the model.

For example, suppose we want to estimate and test the
indirect effect from `x` through `m2` to `y`, bypassing
`m1`, simply set `x` to `"x"`, `y` to `"y"`, and `m` to `"m2"`:

```{r}
out_x_m2_y <- indirect_effect(x = "x",
                              y = "y",
                              m = "m2",
                              fit = fit_med,
                              boot_ci = TRUE,
                              boot_out = out_med)
out_x_m2_y
```

The indirect effect along this path is not significant.

Similarly, indirect effects from `m1` through `m2`  to `y`
or from `x` through `m1` to `y` can also be tested
by setting the three arguments accordingly.

Fit the models first, and explore as many pathways as we want.

# Other Cases

The following articles illustrate other uses of `manymome` (to be prepared):

- Models estimated by multiple regression:
    - Moderated mediation models with categorical and numeric moderators.
    - Moderated mediation models with both categorical and numeric moderators.
    - Parallel mediation models.
    - Complex mediation models.
- Models fitted by structural equation modeling using `lavaan::sem()`:
    - Moderated mediation models with numeric moderators.
    - Moderated mediation models with categorical moderators.
    - Moderated mediation models with both numeric and categorical moderators.
    - Complex mediation models.
    - Indirect effects between latent factors.
    - Models with missing data.

# Moderation-Only Models

Although `cond_indirect_effects()` can also be used for a moderated
regression model without mediators, there are other packages
specifically for this model. For example, `stdmod::cond_effect()`
can be used to compute the conditional effects, and
`stdmod::cond_effect_boot()`, when used with
`stdmod::std_selected()`, can be used to form bootstrap
confidence intervals for standardized conditional effects.
`visreg::visreg()` and `stdmod::plotmod()` can be used to plot
conditional effects in a moderated regression model.
Interested researchers can check the package [stdmod](https://sfcheung.github.io/stdmod/) and
and [visreg](http://pbreheny.github.io/visreg/).

(Disclosure: `stdmod` is also developed by the maintainer
of `manymome`.)

# References

Hayes, A. F. (2018). Partial, conditional, and moderated moderated
mediation: Quantification, inference, and interpretation.
*Communication Monographs, 85*(1), 4-40.
https://doi.org/10.1080/03637751.2017.1352100
