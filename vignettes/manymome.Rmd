---
title: "manymome"
author: "Shu Fai Cheung"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{manymome}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
if (basename(getwd()) == "manymome") {
    pth <- "./vignettes/"
  } else {
    pth <- "./"
  }
```

# Introduction

This article is a brief illustration on how `manymome` functions are
used in some typical cases. The models are intended to be
simple enough for illustration but complicated enough to
show the flexibility of `manymome`.

## Workflow

The use of `manymome` adopts a two-stage workflow:

1. Fit the model by SEM (using `lavaan::sem`) or a series of regression
  (using `lm()`).

    - No need to label any parameters or denote any variables
  as the predictors, mediators, moderators, or outcome variables for
  computing indirect effects or conditional indirect effects.

    - Bootstrapping in this stage is optional. If done at this stage,
      bootstrap estimates can be reused by all main functions of
      `manymome`. No need to do bootstrapping again and again.
      Bootstrapping can also be done in the next stage.

2. Use `manymome` functions to compute the indirect effects or
   conditional indirect effects along
   nearly any path in the model.

    - Just specify the start (`x`), the mediator(s)
   (`m`, if any), and the end (`y`). Indirect effects can be computed
   for nearly any path in a model, and it can start nearly anywhere and end
   nearly anywhere. Bootstrap confidence can be formed for the
   indirect effects.

     - If a path has one or more moderators, conditional
   indirect effects can be computed, again along nearly any path.
   The levels of the moderators can be decided in this stage. No need
   to go back to Stage 1. Bootstrap confidence can be formed for the
   conditional indirect effects.

     - Bootstrapping can be done in this stage, and only needs to
     be conducted once. The bootstrap estimates can be reused by
     most main functions of `manymome`.

## What Will Be Covered

a. Using `cond_indirect_effects()` to compute conditional
   indirect effects, with bootstrap confidence intervals.

a. Using `indirect_effect()` to compute indirect effects,
   with bootstrap confidence interval.

b. Using `do_boot()` to generate bootstrap estimates for
   `cond_indirect_effects()`, `indirect_effect()`,
   and some other functions in `manymome`.

c. Using `index_of_mome()` and `index_of_momome()` to
   compute the index of moderated mediation and the
   index of moderated moderated mediation, respectively,
   with bootstrap confidence intervals.

e. Compute standardized conditional indirect effects
   and standardized indirect effect using
   `cond_indirect_effects()` and `indirect_effect()`,
   respectively.

# Moderated Mediation by SEM using `lavaan`

This is the sample dataset comes with the package:

```{r}
library(manymome)
dat <- data_med_mod_ab
print(head(dat), digits = 3)
```

Suppose this is the model being fitted:

```{r echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
dat$xw1 <- dat$x * dat$w1
dat$mw2 <- dat$m * dat$w2
mod <-
"
xw1 ~ x + w1
m ~ xw1
mw2 ~ m + w2
y ~ mw2
y ~ x
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c("w1", NA, NA, NA, "w2",
                   NA, NA, "m", NA, NA,
                   NA, "xw1", NA, "mw2", NA,
                   "x", NA, NA, NA, "y"), 4, 5, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 10,
              DoNotPlot = TRUE)
p$graphAttributes$Nodes$width[c(1, 3)] <- .01
p$graphAttributes$Nodes$height[c(1, 3)] <- .01
p$graphAttributes$Edges$asize[c(1, 4)] <- 0
plot(p)
```

## Fitting the Model

This is a moderated mediation model with

  - a mediation path `x -> m -> y`, and

  - two moderators: `x -> m` moderated by `w1` and `m -> y` moderated by `w2`.

The effects of interest are the *conditional
indirect effects*: the indirect effects from `x` to `y` through `m` for
different levels of `w1` and `w2`.

The effects in this moderated mediation model can be
estimated by SEM in R using
`lavaan::sem()`.

```{r}
library(lavaan)
dat$w1x <- dat$w1 * dat$x
dat$w2m <- dat$w2 * dat$m
mod <-
"
m ~ x + w1 + w1x
y ~ m + w2 + w2m + x
# Covariance between w2m and the error term of m
w2m ~~ m
# Covariance between w2m and the error term of m
w2m ~~ w2 + x + w1 + w1x
w2  ~~ x + w1 + w1x
x   ~~ w1 + w1x
w1  ~~ w1x
"
fit <- sem(model = mod,
           data = dat,
           fixed.x = FALSE,
           estimator = "MLR")
```

`MLR` is used to take into account probable nonnormality
due to the product terms and allowing the predictors to
be random variables (`fixed.x = FALSE`), which is more
natural in disciplines like social sciences.

These are the parameter estimates:

```{r}
parameterEstimates(fit)[parameterEstimates(fit)$op == "~", ]
```

Both moderation effects are significant. Because the indirect effect
is moderated on both stages (`x -> m` and `m -> y`), the magnitude
of the indirect effect depends on `w1` and `w2`. The indirect
effect conditional on the moderators is called the *conditional*
*indirect* *effect*. Moreover, like a mediation effect without moderation,
its confidence interval can be formed by nonparametric bootstrapping.

## Conditional Indirect Effects

Conventionally, to compute the conditional indirect effects,
we need to define user parameters, and we need to decide in advance
the levels of the moderators. If standardized conditional
indirect effect is needed, then the syntax will be much more complicated
even in this model because the variance of `y` is not a free parameter
and needs to be computed from (many) other parameters.

Using `manymome`, no need to label any coefficients or define any
user parameters, and also no need to request bootstrapping when
calling `lavaan::sem()`. It has functions that (a) generate bootstrap
estimates and this only need to be done once, and (b) compute
the conditional indirect effects for any levels of the moderators
along any path.

### Do Bootstrapping (Once)

The function `do_boot()` can be used to generate and store bootstrap
estimates as well as implied variances and SDs of variables:

```{r}
fit_boot <- do_boot(fit = fit,
                    R = 100,
                    seed = 53253)
```

The minium argument is `fit`, the output of `lavaan::sem()`.
`R` is the number of bootstrap samples, which should be 2000
or even 5000 in real research. `R` is set to 100 here just
for illustration. The `seed` is to make the results
reproducible. By default, parallel processing is used,
and so the results are reproducible only if the number of
processes is the same. See the help of `do_boot()` for
other options.

The output, `fit_boot` in this case, can then be used for
all subsequent analyses on this model.

### Estimating Conditional Indirect Effects

To compute conditional indirect effects and form bootstrap confidence
intervals, we can use `cond_indirect_effects()`.

```{r}
out_cond <- cond_indirect_effects(wlevels =c("w1", "w2"),
                                  x = "x",
                                  y = "y",
                                  m = "m",
                                  fit = fit,
                                  boot_ci = TRUE,
                                  boot_out = fit_boot)
```

These are the major arguments:

- `wlevels`: The vector of the names of the moderators.
- `x`: The name of the predictor.
- `y`: The name of the outcome variable.
- `m`: The name of the mediator, or a vector of names
       if the path has more than one mediator.
- `fit`: The output of `lavaan::sem()`.
- `boot_ci`: Set to `TRUE` to request bootstrap confidence intervals.
             Default is `FALSE`.
- `boot_out`: The pregenerated bootstrap estimates generated
              by `do_boot()` or previous call to
              `cond_indirect_effects()`.

This is the output:

```{r}
out_cond
```

For two or more moderators, the default levels for numeric moderators
are one standard deviation below mean and one standard deviation above
mean. For two moderators, there are four combinations. As shown
above, among these levels, the indirect effect from `x` to `y` through
`m` is significant only when both `w1` and `w2` are one standard deviation
above mean. The indirect effect at these levels of `w1` and `w2` are
`r formatC(coef(out_cond)[1], digits = 3, format = "f")`, with
95% bootstrap confidence interval
[`r paste0(formatC(unlist(confint(out_cond)[1, ]), digits = 3, format = "f"), collapse = ", ")`].

The levels of the moderators, `w1` and `w2` in this example, can be
controlled directly by users. See `mod_levels()` and `merge_mod_levels()`
on how to specify other levels of the moderators. Because `boot_out`
use pregenerated bootstrap estimates, changing the levels of the moderators
does not require doing bootstrapping again.

## Standardized Conditional Indirect Effects

To compute the standardized conditional indirect effects, we can
standardize
only the predictor (`x`), only the outcome (`y`), or both.

To standardize `x`, set `standardized_x` to `TRUE`. To standardize
`y`, set `standardized_y` to `TRUE`. To standardize both,
set both `standardized_x` and `standardized_y` to `TRUE`.

This is the result when both `x` and `y` are standardized:

```{r}
out_cond_stdxy <- cond_indirect_effects(wlevels =c("w1", "w2"),
                                        x = "x",
                                        y = "y",
                                        m = "m",
                                        fit = fit,
                                        boot_ci = TRUE,
                                        boot_out = fit_boot,
                                        standardized_x = TRUE,
                                        standardized_y = TRUE)
```

Note that `fit_boot` is used again, so that there is no need to
do bootstrapping again.

This is the output:

```{r}
out_cond_stdxy
```

The standardized indirect effect when both `w1` and `w2` are
one standard deviation above mean is
`r formatC(coef(out_cond_stdxy)[1], digits = 3, format = "f")`, with
95% bootstrap confidence interval
[`r paste0(formatC(unlist(confint(out_cond_stdxy)[1, ]), digits = 3, format = "f"), collapse = ", ")`].

## Index of Moderated Moderated Mediation

The index of moderated moderated mediation (Hayes, 2018) can
be estimated, along with bootstrap confidence interval, using
the function `index_of_momome()`:

```{r}
out_momome <- index_of_momome(x = "x",
                              y = "y",
                              m = "m",
                              w = "w1",
                              z = "w2",
                              fit = fit,
                              boot_ci = TRUE,
                              boot_out = fit_boot)
```

Again, setting `boot_out` to pregenerated bootstrap estimates
save the time for bootstrapping.

This is the result:

```{r}
out_momome
```

The index of moderated moderated mediation is
`r formatC(coef(out_momome), digits = 3, format = "f")`,
with 95% bootstrap confidence interval
[`r paste0(formatC(unlist(confint(out_momome)[1, ]), digits = 3, format = "f"), collapse = ", ")`].
Although `w1` and `w2` significantly moderate the component paths,
they do not significantly moderate the moderating effect of each Other
on the indirect effect.

## Index of Moderated Mediation

The `manymome` package also has a function to compute the *index of
moderated mediation* (Hayes, 2015). Suppose we modify the model and remove
one of the moderators:

```{r echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
dat$xw1 <- dat$x * dat$w1
dat$mw2 <- dat$m * dat$w2
mod <-
"
xw1 ~ x + w1
m ~ xw1
# mw2 ~ m + w2
y ~ m
y ~ x
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c("w1", NA, "m", NA, NA,
                   NA, "xw1", NA, "mw2", NA,
                   "x", NA, NA, NA, "y"), 3, 5, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 10,
              DoNotPlot = TRUE)
p$graphAttributes$Nodes$width[c(1)] <- .01
p$graphAttributes$Nodes$height[c(1)] <- .01
p$graphAttributes$Edges$asize[c(1)] <- 0
plot(p)
```

This is the `lavaan` model:

```{r}
library(lavaan)
dat$w1x <- dat$w1 * dat$x
mod2 <-
"
m ~ x + w1 + w1x
y ~ m + x
"
fit2 <- sem(model = mod2,
           data = dat,
           fixed.x = FALSE,
           estimator = "MLR")
```

These are the parameterEstimates:

```{r}
parameterEstimates(fit2)[parameterEstimates(fit2)$op == "~", ]
```

We generate the bootstrap estimates first (`R` should be
2000 or even 5000 in real research):

```{r}
fit2_boot <- do_boot(fit = fit2,
                    R = 100,
                    seed = 53253)
```

The function `index_of_mome()` can be used to compute
the index of moderated mediation of `w1` on the
path `x -> m -> y`:

```{r}
out_mome <- index_of_mome(x = "x",
                          y = "y",
                          m = "m",
                          w = "w1",
                          fit = fit2,
                          boot_ci = TRUE,
                          boot_out = fit2_boot)
```

The arguments are nearly identical to those of `index_of_momome()`,
except that only `w` needs to be specified. This is the output:

```{r}
out_mome
```

In this model, the index of moderated mediation is
`r formatC(coef(out_mome), digits = 3, format = "f")`,
with 95% bootstrap confidence interval
[`r paste0(formatC(unlist(confint(out_mome)[1, ]), digits = 3, format = "f"), collapse = ", ")`].
The moderator `w1` does not significantly moderate the
indirect effect of `x` on `y` through `m`.

# Mediation Only

The package can also be used for a mediation model.

This is the sample dataset comes with the package:

```{r}
library(manymome)
dat <- data_serial
print(head(dat), digits = 3)
```

Suppose this is the model being fitted, with `c1` and
`c2` the control variables.

```{r echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
mod <-
"m1 ~ x + c1 + c2
m2 ~ m1 + x + c1 + c2
y ~ m2 + m1 + x + c1 + c2
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c(NA, "m1", "m2", NA,
                     "x", NA, NA, "y",
                     "c1", NA, NA, NA,
                     "c2", NA, NA, NA), 4, 4, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 5,
              DoNotPlot = TRUE)
plot(p)
```

## Fitting the Model

Fitting this model in `lavaan::sem()` is very simple:

```{r}
mod_med <- "
m1 ~ x + c1 + c2
m2 ~ m1 + x + c1 + c2
y ~ m2 + m1 + x + c1 + c2
"
fit_med <- sem(model = mod_med,
               data = dat,
               fixed.x = TRUE)
```
These are the estimates

```{r}
parameterEstimates(fit_med)[parameterEstimates(fit_med)$op == "~", ]
```

## Estimating Indirect Effects

`indirect_effect()` can be used to estimate the indirect effect
and form its bootstrapping confidence interval along a path
in a model
that starts with any variable (predictor), ends with
any variable (outcome variable), through any variable(s) (mediator(s)).

Unlike the previous example, we illustrate how to
generate bootstrap estimates when calling `indirect_effect()`
instead of using `do_boot()`.

For example, this is the call for the indirect effect
from `x` to `y` through `m1` and `m2`:

```{r}
out_med <- indirect_effect(x = "x",
                           y = "y",
                           m = c("m1", "m2"),
                           fit = fit_med,
                           boot_ci = TRUE,
                           R = 100,
                           seed = 43143)
```

The main arguments are:

- `x`: The name of the predictor. The start of the path.
- `y`: The name of the outcome variable. The end of the path
- `m`: The name of the mediator, or the vector of names of the
        mediators if the path has more than one mediator,
        as in this example. The path moves from the first
        mediator to the last mediator. In this example,
        the correct order is `c("m1", "m2")`.
- `fit`: The output of `lavaan::sem()`.
- `boot_ci`: Set to `TRUE` to request bootstrapping confidence intervals.
             Default is `FALSE`.
- `R`: The number of bootstrap samples. Only 500 bootstrap samples
        for illustration. Set `R` to 2000 or even 5000 in real research.
- `seed`: The seed for the random number generator.

This is the output:

```{r}
out_med
```

The indirect effect from `x` to `y` through `m1` and `m2`
is `r formatC(coef(out_med), digits = 3, format = "f")`,
with a 95% confidence interval of
[`r paste0(formatC(confint(out_med), digits = 3, format = "f"), collapse = ", ")`],
significantly different from zero (*p* < .05).

Because bootstrap confidence interval is requested, the
bootstrap estimates are stored in `out_med` and so it
can also be used in the argument `boot_out`.

## Standardized Indirect Effect

To compute the indirect effect with the predictor standardized,
set `standardized_x` to `TRUE`. To compute the indirect effect
with the outcome variable standardized, set `standardized_y`
to `TRUE`. To compute the (completely) standardized
indirect effect, set both `standardized_x` and
`standardized_y` to `TRUE`.

This is the call to compute the (completely) standardized
indirect effect:

```{r}
out_med_stdxy <- indirect_effect(x = "x",
                                 y = "y",
                                 m = c("m1", "m2"),
                                 fit = fit_med,
                                 boot_ci = TRUE,
                                 boot_out = out_med,
                                 standardized_x = TRUE,
                                 standardized_y = TRUE)
out_med_stdxy
```

The indirect effect from `x` to `y` through `m1` and `m2`
is `r formatC(coef(out_med_stdxy), digits = 3, format = "f")`,
with a 95% confidence interval of
[`r paste0(formatC(confint(out_med_stdxy), digits = 3, format = "f"), collapse = ", ")`],
significantly different from zero (*p* < .05).

## Estimating Indirect Effects For *Any* Paths

`indirect_effect()` can be used for the indirect effect
in any path in a path model. There is no need to specify
the path when specifying the model.

For example, suppose we want to estimate and test the
indirect effect from `x` through `m2` to `y`, bypassing
`m1`, simply set `x` to `"x"`, `y` to `"y"`, and `m` to `"m2"`:

```{r}
out_x_m2_y <- indirect_effect(x = "x",
                              y = "y",
                              m = "m2",
                              fit = fit_med,
                              boot_ci = TRUE,
                              boot_out = out_med)
out_x_m2_y
```

The indirect effect along this path is not significant.

Similarly, indirect effects from `m1` through `m2`  to `y`
or from `x` through `m1` to `y` can also be tested
by setting the three arguments accordingly. Users do not
need to decide in advance to compute the indirect effects
for which path.

# Summary

(To be prepared)

# References

Hayes, A. F. (2018). Partial, conditional, and moderated moderated
mediation: Quantification, inference, and interpretation.
*Communication Monographs, 85*(1), 4-40.
https://doi.org/10.1080/03637751.2017.1352100
