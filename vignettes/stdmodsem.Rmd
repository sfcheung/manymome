---
title: "stdmodsem"
author: "Shu Fai Cheung"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{stdmodsem}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
if (basename(getwd()) == "stdmodsem") {
    pth <- "./vignettes/"
  } else {
    pth <- "./"
  }
```

# Introduction

This article is a brief illustration on how `stdmodsem` functions are
used in some typical cases.

# Moderated Mediation: Multiple Regression by `lm()`

This is the sample dataset comes with the package:

```{r}
library(stdmodsem)
dat <- data_med_mod_ab
print(head(dat), digits = 3)
```

Suppose this is the model being fitted:

```{r echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
dat$xw1 <- dat$x * dat$w1
dat$mw2 <- dat$m * dat$w2
mod <-
"
xw1 ~ x + w1
m ~ xw1
mw2 ~ m + w2
y ~ mw2
y ~ x
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c("w1", NA, NA, NA, "w2",
                   NA, NA, "m", NA, NA,
                   NA, "xw1", NA, "mw2", NA,
                   "x", NA, NA, NA, "y"), 4, 5, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 10,
              DoNotPlot = TRUE)
p$graphAttributes$Nodes$width[c(1, 3)] <- .01
p$graphAttributes$Nodes$height[c(1, 3)] <- .01
p$graphAttributes$Edges$asize[c(1, 4)] <- 0
plot(p)
```

```{r}
lm_m <- lm(m ~ x * w1, dat)
lm_y <- lm(y ~ m * w2 + x, dat)
```

This is a mediation model, `x -> m -> y`, with both paths
moderated, `x -> m` by `w1`, and `m -> y` by `w2`.

These are the coefficients:

```{r}
printCoefmat(summary(lm_m)$coefficients, digits = 3)
printCoefmat(summary(lm_y)$coefficients, digits = 3)
```

To compute conditional indirect effects and form bootstrap confidence
intervals, we use `cond_indirect_effects()`. For a model with coefficients
estimate by multiple regression, we first group the `lm()` outputs to a `list`.

This can be done by `lm2list()`, which will also check the `lm()` outputs
to see whether they can from a model and whether exactly the cases are used
in all modlels:


```{r}
fit_lm <- lm2list(lm_m, lm_y)
fit_lm
```

We then use `mod_levels_list()` to generate combinations of levels of the
moderators, 1 SD below and above means in this example by setting
`sd_from_mean`:

```{r}
mod_levels <- mod_levels_list("w1", "w2",
                              fit = fit_lm,
                              sd_from_mean = c(-1, 1),
                              merge = TRUE)
mod_levels
```

To form bootstrapping confidence intervals, we first repeat the regression
analysis in all models by nonparametric bootstrapping and store the results.
This can be done by `lm2boot_out()`:

```{r echo = FALSE}
fn <- paste0(pth, "stdmodsem_fit_lm_boot_out.rds")
if (file.exists(fn)) {
    fit_lm_boot_out <- readRDS(fn)
  } else {
    fit_lm_boot_out <- lm2boot_out(fit_lm, R = 2000, seed = 87415)
    saveRDS(fit_lm_boot_out, fn)
  }
```

```{r eval = FALSE}
fit_lm_boot_out <- lm2boot_out(fit_lm, R = 2000, seed = 87415)
```

It is all set. We can now compute the conditional indirect effect:

```{r}
out_lm <- cond_indirect_effects(wlevels = mod_levels,
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = fit_lm,
                             boot_ci = TRUE,
                             boot_out = fit_lm_boot_out)
out_lm
```

These are the standardized conditional indirect effects:

```{r}
out_lm_std <- cond_indirect_effects(wlevels = mod_levels,
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = fit_lm,
                             boot_ci = TRUE,
                             boot_out = fit_lm_boot_out,
                             standardized_x = TRUE,
                             standardized_y = TRUE)
out_lm_std
```

# Moderated Mediation: Path Analysis by `lavaan::sem()`

Suppose we fit the same model, but by path analysis.

```{r}
library(lavaan)
mod <-
"
m ~ x + w1 + x:w1
y ~ m + w2 + m:w2 + x
"
fit_lavaan <- sem(model = mod,
                  data = dat,
                  fixed.x = FALSE)
```

It is not recommended to set `se` to `"boot"` for bootstrapping.
`fit2boot_out_do_boot()` can be used to compute only information
necessary for this package. It also supports parallel processing.

```{r echo = FALSE}
fn <- paste0(pth, "stdmodsem_fit_lavaan_boot_out.rds")
if (file.exists(fn)) {
    fit_lavaan_boot_out <- readRDS(fn)
  } else {
    fit_lavaan_boot_out <- fit2boot_out_do_boot(fit = fit_lavaan,
                                                R = 2000,
                                                seed = 8715,
                                                parallel = TRUE,
                                                ncores = 2)
    saveRDS(fit_lavaan_boot_out, fn)
  }
```

```{r eval = FALSE}
fit_lavaan_boot_out <- fit2boot_out_do_boot(fit = fit_lavaan,
                                            R = 2000,
                                            seed = 8715,
                                            parallel = TRUE,
                                            ncores = 2)
```

We can use `mod_levels_list()` to generate levels of the moderators:

```{r}
mod_levels <- mod_levels_list("w1", "w2",
                              fit = fit_lavaan,
                              sd_from_mean = c(-1, 1),
                              merge = TRUE)
mod_levels
```

We then use `cond_indirect_effects()` to compute the
conditional indirect effects, with nonparametric bootstrapping
confidence intervals:

```{r}
out_lavaan <- cond_indirect_effects(wlevels = mod_levels,
                                    x = "x",
                                    y = "y",
                                    m = "m",
                                    fit = fit_lavaan,
                                    boot_ci = TRUE,
                                    boot_out = fit_lavaan_boot_out)
out_lavaan
```

These are the standardized conditional indirect effects:

```{r}
out_lavaan_std <- cond_indirect_effects(wlevels = mod_levels,
                                        x = "x",
                                        y = "y",
                                        m = "m",
                                        fit = fit_lavaan,
                                        boot_ci = TRUE,
                                        boot_out = fit_lavaan_boot_out,
                                        standardized_x = TRUE,
                                        standardized_y = TRUE)
out_lavaan_std
```

# Mediation: Multiple Regression by `lm()`

# Mediation: Path Analysis by `lavaan::sem()`

# Further Information