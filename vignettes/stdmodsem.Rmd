---
title: "stdmodsem"
author: "Shu Fai Cheung"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{stdmodsem}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
if (basename(getwd()) == "stdmodsem") {
    pth <- "./vignettes/"
  } else {
    pth <- "./"
  }
```

# Introduction

This article is a brief illustration on how `stdmodsem` functions are
used in some typical cases.

# Moderated Mediation

This is the sample dataset comes with the package:

```{r}
library(stdmodsem)
dat <- data_med_mod_ab
print(head(dat), digits = 3)
```

Suppose this is the model being fitted:

```{r echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
dat$xw1 <- dat$x * dat$w1
dat$mw2 <- dat$m * dat$w2
mod <-
"
xw1 ~ x + w1
m ~ xw1
mw2 ~ m + w2
y ~ mw2
y ~ x
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c("w1", NA, NA, NA, "w2",
                   NA, NA, "m", NA, NA,
                   NA, "xw1", NA, "mw2", NA,
                   "x", NA, NA, NA, "y"), 4, 5, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 10,
              DoNotPlot = TRUE)
p$graphAttributes$Nodes$width[c(1, 3)] <- .01
p$graphAttributes$Nodes$height[c(1, 3)] <- .01
p$graphAttributes$Edges$asize[c(1, 4)] <- 0
plot(p)
```

This is a moderated mediation model with

  - a mediation path `x -> m -> y`, and

  - two moderators: `x -> m` moderated by `w1` and `m -> y` moderated by `w2`.

The effects of interest are the *conditional
indirect effects*: the indirect effects from `x` to `y` through `m` for
different levels of `w1` and `w2`.

There are two common approaches to test and estimate these
effects: regression approach and structural equation modelling
approach. The following sections will illustrate these two
approaches.

## Multiple Regression by `lm()`


```{r}
lm_m <- lm(m ~ x * w1, dat)
lm_y <- lm(y ~ m * w2 + x, dat)
```


These are the coefficients:

```{r}
printCoefmat(summary(lm_m)$coefficients, digits = 3)
printCoefmat(summary(lm_y)$coefficients, digits = 3)
```

To compute conditional indirect effects and form bootstrap confidence
intervals, we use `cond_indirect_effects()`. For a model with coefficients
estimate by multiple regression, we first group the `lm()` outputs to a `list`.

This can be done by `lm2list()`, which will also check the `lm()` outputs
to see whether they can from a model and whether exactly the cases are used
in all models:


```{r}
fit_lm <- lm2list(lm_m, lm_y)
fit_lm
```

We then use `mod_levels_list()` to generate combinations of levels of the
moderators, 1 SD below and above means in this example by setting
`sd_from_mean`:

```{r}
mod_levels <- mod_levels_list("w1", "w2",
                              fit = fit_lm,
                              sd_from_mean = c(-1, 1),
                              merge = TRUE)
mod_levels
```

To form bootstrapping confidence intervals, we first repeat the regression
analysis in all models by nonparametric bootstrapping and store the results.
This can be done by `lm2boot_out()`:

```{r echo = FALSE}
fn <- paste0(pth, "stdmodsem_fit_lm_boot_out.rds")
if (file.exists(fn)) {
    fit_lm_boot_out <- readRDS(fn)
  } else {
    fit_lm_boot_out <- lm2boot_out(fit_lm, R = 2000, seed = 87415)
    saveRDS(fit_lm_boot_out, fn)
  }
```

```{r eval = FALSE}
fit_lm_boot_out <- lm2boot_out(fit_lm, R = 2000, seed = 87415)
```

It is all set. We can now compute the conditional indirect effect:

```{r}
out_lm <- cond_indirect_effects(wlevels = mod_levels,
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = fit_lm,
                             boot_ci = TRUE,
                             boot_out = fit_lm_boot_out)
out_lm
```

These are the standardized conditional indirect effects:

```{r}
out_lm_std <- cond_indirect_effects(wlevels = mod_levels,
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = fit_lm,
                             boot_ci = TRUE,
                             boot_out = fit_lm_boot_out,
                             standardized_x = TRUE,
                             standardized_y = TRUE)
out_lm_std
```

## Path Analysis by `lavaan::sem()`

Suppose we fit the same model, but by path analysis conducted in
by structural equation modelling analysis using `lavaan::sem()`.

```{r}
library(lavaan)
mod <-
"
m ~ x + w1 + x:w1
y ~ m + w2 + m:w2 + x
"
fit_lavaan <- sem(model = mod,
                  data = dat,
                  fixed.x = FALSE)
```

It is not recommended to set `se` to `"boot"` for bootstrapping.
`fit2boot_out_do_boot()` can be used to compute only information
necessary for this package. It also supports parallel processing.

```{r echo = FALSE}
fn <- paste0(pth, "stdmodsem_fit_lavaan_boot_out.rds")
if (file.exists(fn)) {
    fit_lavaan_boot_out <- readRDS(fn)
  } else {
    fit_lavaan_boot_out <- fit2boot_out_do_boot(fit = fit_lavaan,
                                                R = 2000,
                                                seed = 8715,
                                                parallel = TRUE,
                                                ncores = 2)
    saveRDS(fit_lavaan_boot_out, fn)
  }
```

```{r eval = FALSE}
fit_lavaan_boot_out <- fit2boot_out_do_boot(fit = fit_lavaan,
                                            R = 2000,
                                            seed = 8715,
                                            parallel = TRUE,
                                            ncores = 2)
```

We can use `mod_levels_list()` to generate levels of the moderators:

```{r}
mod_levels <- mod_levels_list("w1", "w2",
                              fit = fit_lavaan,
                              sd_from_mean = c(-1, 1),
                              merge = TRUE)
mod_levels
```

We then use `cond_indirect_effects()` to compute the
conditional indirect effects, with nonparametric bootstrapping
confidence intervals:

```{r}
out_lavaan <- cond_indirect_effects(wlevels = mod_levels,
                                    x = "x",
                                    y = "y",
                                    m = "m",
                                    fit = fit_lavaan,
                                    boot_ci = TRUE,
                                    boot_out = fit_lavaan_boot_out)
out_lavaan
```

These are the standardized conditional indirect effects:

```{r}
out_lavaan_std <- cond_indirect_effects(wlevels = mod_levels,
                                        x = "x",
                                        y = "y",
                                        m = "m",
                                        fit = fit_lavaan,
                                        boot_ci = TRUE,
                                        boot_out = fit_lavaan_boot_out,
                                        standardized_x = TRUE,
                                        standardized_y = TRUE)
out_lavaan_std
```

# Mediation Only

The function `cond_indirect()` also supports a path model without
moderator. It can be used for complicated models with any number of
predictors, mediators, outcome variables, and paths.

This is the sample dataset comes with the package:

```{r}
library(stdmodsem)
dat <- data_med_complicated
print(head(dat), digits = 3)
```

Suppose this is the model being fitted:

```{r echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
mod <-
"
m11 ~ x1
m12 ~ m11 + x1
m2 ~ x2
y1 ~ m12 + x1 + m11 + x2
y2 ~ m2 + x2 + x1
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c(NA, "m11", NA, "m12", NA,
                     "x1", NA, NA, NA, "y1",
                     "x2", NA, NA, NA, "y2",
                     NA, NA, "m2", NA, NA), 4, 5, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = TRUE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 5,
              # curve = rep(2, 15),
              DoNotPlot = TRUE)
p$graphAttributes$Edges$curve[c(12:13, 14:15)] <- c(6, -6, 0, 0)
plot(p)
```

## Multiple Regression by `lm()`

Although it is common in regression-based mediation analysis to
include all possible paths to make a model saturated, we illustrate
how to fit the intended model by multiple regression.

```{r}
lm_m11 <- lm(m11 ~ x1, dat)
lm_m12 <- lm(m12 ~ m11 + x1, dat)
lm_y1 <- lm(y1 ~ m12 + m11 + x1 + x2, dat)
lm_m2 <- lm(m2 ~ x2, dat)
lm_y2 <- lm(y2 ~ m2 + x1 + x2, dat)
```

These are the coefficients:

- From `x1` to `y1`:

```{r}
printCoefmat(summary(lm_m11)$coefficients, digits = 3, signif.legend = FALSE)
printCoefmat(summary(lm_m12)$coefficients, digits = 3, signif.legend = FALSE)
printCoefmat(summary(lm_y1)$coefficients, digits = 3, signif.legend = FALSE)
```

- From `x2` to `y2`:

```{r}
printCoefmat(summary(lm_m2)$coefficients, digits = 3, signif.legend = FALSE)
printCoefmat(summary(lm_y2)$coefficients, digits = 3, signif.legend = FALSE)
```

To compute indirect effects and form bootstrap confidence
intervals, we use `cond_indirect_effects()`. We first group
the `lm()` outputs to a `list` by `lm2list()`.

```{r}
fit_lm <- lm2list(lm_m11, lm_m12, lm_y1, lm_m2, lm_y2)
fit_lm
```

To form bootstrapping confidence intervals, we first repeat the regression
analysis in all models by nonparametric bootstrapping and store the results.
This can be done by `lm2boot_out()`:

```{r echo = FALSE}
fn <- paste0(pth, "stdmodsem_fit_lm_boot_out_complicated.rds")
if (file.exists(fn)) {
    fit_lm_boot_out_complicated <- readRDS(fn)
  } else {
    fit_lm_boot_out_complicated <- lm2boot_out(fit_lm,
          R = 2000, seed = 87415)
    saveRDS(fit_lm_boot_out_complicated, fn)
  }
```

```{r eval = FALSE}
fit_lm_boot_out_complicated <- lm2boot_out(fit_lm, R = 2000, seed = 87415)
```

We can now compute the indirect effects. There are several
possible pathways. `cond_indirect()` does not require
the pathways to be specified before fitting the models. The
pathway can be specified when calling it.

For example, suppose we want to estimate the indirect effect
through `x1 -> m11 -> m12 -> y1`. We set `x` to the
start of the pathway, `y` to the end of the pathway,
and `m` to the sequence of mediators, from left to right:

```{r}
out_x1y1 <- cond_indirect(x = "x1",
                          y = "y1",
                          m = c("m11", "m12"),
                          fit = fit_lm,
                          boot_ci = TRUE,
                          boot_out = fit_lm_boot_out_complicated)
out_x1y1
```

The indirect effect in the pathway `x2 -> m2 -> y2` can be
estimated similarly:

```{r}
out_x2y2 <- cond_indirect(x = "x2",
                          y = "y2",
                          m = "m2",
                          fit = fit_lm,
                          boot_ci = TRUE,
                          boot_out = fit_lm_boot_out_complicated)
out_x2y2
```

Suppose we are interested in the indirect effect from `x1`
to `y1` through `m11` only, bypassing `m12`. This can be done
by setting `m` only to `m11`:

```{r}
out_x1y1_m11 <- cond_indirect(x = "x1",
                              y = "y1",
                              m = "m12",
                              fit = fit_lm,
                              boot_ci = TRUE,
                              boot_out = fit_lm_boot_out_complicated)
out_x1y1_m11
```

It is also possible to estimate the indirect effect only in a segment
of a pathway, for example, from `m11` through `m12` to `y1`:

```{r}
out_m11y1 <- cond_indirect(x = "m11",
                           y = "y1",
                           m = "m12",
                           fit = fit_lm,
                           boot_ci = TRUE,
                           boot_out = fit_lm_boot_out_complicated)
out_m11y1
```

## Path Analysis by `lavaan::sem()`

Suppose we fit the same model, but by path analysis conducted in
by structural equation modelling analysis using `lavaan::sem()`.

```{r}
library(lavaan)
mod <-
"
m11 ~ x1
m12 ~ m11 + x1
y1 ~ m12 + m11 + x1 + x2
m2 ~ x2
y2 ~ m2 + x1 + x2
"
fit_lavaan <- sem(model = mod,
                  data = dat,
                  fixed.x = FALSE)
```

It is not recommended to set `se` to `"boot"` for bootstrapping.
`fit2boot_out_do_boot()` can be used to compute only information
necessary for this package. It also supports parallel processing.

```{r echo = FALSE}
fn <- paste0(pth, "stdmodsem_fit_lavaan_boot_out_complicated.rds")
if (file.exists(fn)) {
    fit_lavaan_boot_out_complicated <- readRDS(fn)
  } else {
    fit_lavaan_boot_out_complicated <- fit2boot_out_do_boot(fit = fit_lavaan,
                                                R = 2000,
                                                seed = 8715,
                                                parallel = TRUE,
                                                ncores = 2)
    saveRDS(fit_lavaan_boot_out_complicated, fn)
  }
```

```{r eval = FALSE}
fit_lavaan_boot_out_complicated <- fit2boot_out_do_boot(fit = fit_lavaan,
                                            R = 2000,
                                            seed = 8715,
                                            parallel = TRUE,
                                            ncores = 2)
```

We can now compute the indirect effects. There are several
possible pathways. `cond_indirect()` does not require
the pathways to be specified before fitting the models. The
pathway can be specified when calling it.

For example, suppose we want to estimate the indirect effect
through `x1 -> m11 -> m12 -> y1`. We set `x` to the
start of the pathway, `y` to the end of the pathway,
and `m` to the sequence of mediators, from left to right:

```{r}
out_x1y1 <- cond_indirect(x = "x1",
                          y = "y1",
                          m = c("m11", "m12"),
                          fit = fit_lavaan,
                          boot_ci = TRUE,
                          boot_out = fit_lavaan_boot_out_complicated)
out_x1y1
```

The indirect effect in the pathway `x2 -> m2 -> y2` can be
estimated similarly:

```{r}
out_x2y2 <- cond_indirect(x = "x2",
                          y = "y2",
                          m = "m2",
                          fit = fit_lavaan,
                          boot_ci = TRUE,
                          boot_out = fit_lavaan_boot_out_complicated)
out_x2y2
```

Suppose we are interested in the indirect effect from `x1`
to `y1` through `m11` only, bypassing `m12`. This can be done
by setting `m` only to `m11`:

```{r}
out_x1y1_m11 <- cond_indirect(x = "x1",
                              y = "y1",
                              m = "m12",
                              fit = fit_lavaan,
                              boot_ci = TRUE,
                              boot_out = fit_lavaan_boot_out_complicated)
out_x1y1_m11
```

It is also possible to estimate the indirect effect only in a segment
of a pathway, for example, from `m11` through `m12` to `y1`:

```{r}
out_m11y1 <- cond_indirect(x = "m11",
                           y = "y1",
                           m = "m12",
                           fit = fit_lavaan,
                           boot_ci = TRUE,
                           boot_out = fit_lavaan_boot_out_complicated)
out_m11y1
```

# More Cases

## A Latent Variable model

## Missing Data

# Further Information