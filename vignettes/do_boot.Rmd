---
title: "Generating Bootstrap Estimates"
author: "Shu Fai Cheung & Sing-Hang Cheung"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Generating Bootstrap Estimates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This article is a brief illustration of how `do_boot()` can
be used to generate bootstrap estimates for use
by `indirect_effect()` and `cond_indirect_effects()` to
form percentile bootstrap confidence interval.

Although `indirect_effect()` and `cond_indirect_effects()`
can also be used to generate bootstrap estimates, there
may be situations in which users prefer generating
the bootstrap estimates first before calling `indirect_effect()`
and `cond_indirect_effects()`.

# Data Set and Model

This data set will be used for illustration:

```{r data}
library(manymome)
dat <- data_med
head(dat)
```

This simple mediation model with two
control variables (`c1` and `c2`)
will be fitted.

```{r draw_model, echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
mod <-
"
m ~ x + c1 + c2
y ~ m + x + c1 + c2
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c(NA, "m", NA,
                     "x", NA, "y",
                     "c1", NA, NA,
                     "c2", NA, NA), 4, 3, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 10,
              DoNotPlot = TRUE)
plot(p)
text(label = "Covariances excluded for readability",
     x = .25, y = -1,
     adj = c(.5, .5))
```

# Models Fitted by `lavaan::sem()`

We first fit the model by `lavaan::sem()`:

```{r fit_by_lavaan}
mod <-
"
m ~ x + c1 + c2
y ~ m + x + c1 + c2
"
fit_lavaan <- sem(model = mod, data = dat,
           fixed.x = FALSE,
           estimator = "MLR")
summary(fit_lavaan)
```

Suppose we would like to robust "sandwich"
standard errors and confidence intervals
provided by MLR for the free parameters,
but want percentile nonparametric bootstrap
confidence interval for indirect effect.
We can call `do_boot()` on the output of
`lavaan::sem()` to generate the bootstrap
estimates of all free parameters *and*
the implied statistics, such as the variances
of `m` and `y`, which are not free parameters
but are needed to forming the confidence
intervals of standardized indirect effect.

```{r do_boot_lavaan}
boot_out_lavaan <- do_boot(fit = fit_lavaan,
                           R = 100,
                           ncores = 1)
```

Usually, just three arguments are needed:

- `fit`: The output of `lavaan::sem()`.

- `R`: The number of bootstrap samples. Should
  be at least 2000 or even 5000 in real
  research. 100 is used here just for illustration.

- `ncores`: The number of CPU cores to be used
  in generating bootstrap estimates.

Parallel processing is enabled by default,
and a progress bar (generated by the package `pbapply`)
will be displayed. The number of cores (`ncores`)
to be used will be decided automatically and
so users usually do not need to change it. It
is set to 1 here just for illustration.

In real research with a complicated model and
moderate to large sample size, even with
parallel processing, it may take several minutes,
or even over twenty minutes in some cases.
Therefore, it is nearly always good to save
the output using `saveRDS()` or `save()`:

```{r do_boot_lav_save, eval = FALSE}
### Use saveRDS() ###
# Save the output
saveRDS(boot_out_lavaan, file = "boot_out_lavaan.rds")
# Load the output
boot_out_lavaan <- readRDS("boot_out_lavaan.rds")

### Use save() ###
# Save the output
save(boot_out_lavaan, file = "boot_out_lavaan.RData")
# Load the output
load("boot_out_lavaan.RData")
```

We recommend `readRDS()` although `save()`
is probably a more popular function.

## The Structure of the Output

The output of `do_boot()` in this case
is an object of the class `boot_out`,
which is a list of `R` lists, each with
three elements: `est`, `implied_stats`,
and `ok`.

This is the content of `est` of the first list:

```{r boot_out_est}
boot_out_lavaan[[1]]$est
```

The content is just the first four columns of
the output of `lavaan::parameterEstimates()`.

This is the content of `implied_stats` of the
first list:

```{r boot_out_implied_stats}
boot_out_lavaan[[1]]$implied_stats
```

It has three elements. `cov` is the implied
variances and covariances of all variables.
If a model has latent variables, they will
be included too. The other elements,
`mean` and `mean_lv`, are the implied
means of the observed variables and
the latent variables (if any), respectively.
They are of zero length if mean structure is
not in the fitted model.

The last element, `ok`, denotes whether
the solution in a bootstrap sample is
admissible or not (determined by
`lavaan::lavInspect()` with
`what = "post.check"`). If not admissible,
it will not be used in forming confidence
intervals.

## Using the Output of `do_boot()`

When calling `indirect_effect()` or
`cond_indirect_effects()` and set the
argument `boot_out` to the output of
`do_bout()`:

```{r indirect_lav}
out_lavaan <- indirect_effect(x = "x",
                              y = "y",
                              m = "m",
                              fit = fit_lavaan,
                              boot_ci = TRUE,
                              boot_out = boot_out_lavaan)
out_lavaan
```

# Models Fitted by Several Calls to `lm()`

Suppose we estimate the parameters using
multiple regression. We need to fit two
regression models, one predicts `m` and
the other predicts `y`:

```{r fit_by_lm}
lm_m <- lm(m ~ x + c1 + c2, dat)
lm_y <- lm(y ~ m + x + c1 + c2, dat)
summary(lm_m)
summary(lm_y)
```

To use `do_boot()`, we first combine the
regression outputs to one object using
`lm2list()`.

```{r lm2list}
fit_lm <- lm2list(lm_m, lm_y)
fit_lm
```

We can now use `do_boot()` as described
above:

```{r do_boot_lm}
boot_out_lm <- do_boot(fit = fit_lm,
                       R = 100,
                       seed = 98715)
```

Speed is rarely a concern for a model with
parameters estimated by `lm()`. Therefore,
parallel processing is not used. Because
the output may not be saved, it is
recommended to set the seed of the random
number generation using `seed`, set
to 98715 in the above example (it can
be any integer within the range allowed
in R, see `set.seed()`). This
ensures that the same `R` set of bootstrap
samples will be generated every time.

## The Structure of the Output

The output of `do_boot()` using the
outputs of `lm()` is identical to
that using the output of `lavaan::sem()`. It is an object of the
class `boot_out`,
which is a list of `R` lists, each with
two elements: `est` and `implied_stats`.

This is the content of `est` of the first list:

```{r boot_out_est_lm}
boot_out_lm[[1]]$est
```

The content is similar in structure
to the output of `lavaan::parameterEstimates()`.
However, the estimates are the estimates
based on `lm()`.

This is the content of `implied_stats` of the
first list:

```{r boot_out_implied_stats_lm}
boot_out_lm[[1]]$implied_stats
```

It has two elements. `cov` is the
variances and covariances of all variables.
Unlike the output based on `lavaan::sem()`,
the content is just the sample variances
and covariances of the variables in each
bootstrap samples, generated using `cov()`.
The other element,
`mean`, stores sample means of all variables
in each bootstrap samples.

## Using the Output of `do_boot()`

When calling `indirect_effect()` or
`cond_indirect_effects()` and set the
argument `boot_out` to the output of
`do_bout()`:

```{r indirect_lm}
out_lm <- indirect_effect(x = "x",
                          y = "y",
                          m = "m",
                          fit = fit_lm,
                          boot_ci = TRUE,
                          boot_out = boot_out_lm)
out_lm
```

# Further Information

For further information on `do_boot()`,
please refer to their help pages.