---
title: "Generate Bootstrap Estimates"
author: "Shu Fai Cheung & Sing-Hang Cheung"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Generate Bootstrap Estimates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = ""
)
```

# Introduction

This article is a brief illustration of how
to use `do_boot()` from the package
[manymome](https://sfcheung.github.io/manymome/index.html)
([Cheung & Cheung, 2023](https://doi.org/10.3758/s13428-023-02224-z))
to generate bootstrap estimates for
`indirect_effect()` and `cond_indirect_effects()` to
form percentile bootstrap confidence intervals.

Although `indirect_effect()` and `cond_indirect_effects()`
can also be used to generate bootstrap estimates
when they are called (see `vignette("manymome")`), there
may be situations in which users prefer generating
the bootstrap estimates first before calling `indirect_effect()`
and `cond_indirect_effects()`. `do_boot()` is for
this purpose.

# The Workflow

The following workflow will be demonstrated;

1. Fit the model as usual.

2. Use `do_boot()` to generate the bootstrap estimates.

3. Call other functions (e.g, `indirect_effect()`
   and `cond_indirect_effects()`) to compute the desired
   effects and form bootstrap confidence intervals.

# Demonstration: `lavaan::sem()`

## Fit a Model by `lavaan::sem()`

The data set for illustration:

```{r data}
library(manymome)
dat <- data_med
head(dat)
```

It has one predictor (`x`), one mediator (`m`),
one outcome variable (`y`), and two control
variables (`c1` and `c2`).

This simple mediation model with two
control variables (`c1` and `c2`)
will be fitted:

```{r do_boot_draw_model, echo = FALSE}
library(semPlot)
suppressMessages(library(lavaan))
mod <-
"
m ~ x + c1 + c2
y ~ m + x + c1 + c2
"
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c(NA, "m", NA,
                     "x", NA, "y",
                     "c1", NA, NA,
                     "c2", NA, NA), 4, 3, byrow = TRUE)
p <- semPaths(fit0,
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              residuals = FALSE,
              sizeMan = 10,
              asize = 10,
              DoNotPlot = TRUE)
plot(p)
text(label = "(Covariances excluded for readability)",
     x = .25, y = -1,
     adj = c(.5, .5))
```

We first fit the model by `lavaan::sem()`:

```{r fit_by_lavaan}
mod <-
"
m ~ x + c1 + c2
y ~ m + x + c1 + c2
"
fit_lavaan <- sem(model = mod, data = dat,
           fixed.x = FALSE,
           estimator = "MLR")
summary(fit_lavaan)
```

Suppose we would like to use robust "sandwich"
standard errors and confidence intervals
provided by MLR for the free parameters,
but want to use percentile nonparametric
bootstrap
confidence interval for the indirect effect.
In the call above, we used `estimator = "MLR"`
and did not set `se = "boot"`.

## Generate Bootstrap Estimates

We can then call `do_boot()` on the output of
`lavaan::sem()` to generate the bootstrap
estimates of all free parameters *and*
the implied statistics, such as the variances
of `m` and `y`, which are not free parameters
but are needed to form the confidence
interval of the *standardized* indirect effect.

```{r do_boot_lavaan}
boot_out_lavaan <- do_boot(fit = fit_lavaan,
                           R = 100,
                           ncores = 1,
                           seed = 58491)
```

Usually, just three arguments are needed:

- `fit`: The output of `lavaan::sem()`.

- `R`: The number of bootstrap samples. Should
  be at least 2000 or even 5000 in real
  research. 100 is used here just for illustration.

- `ncores`: The number of CPU cores to be used
  in generating bootstrap estimates in parallel
  processing.

- `seed`: The seed for the random number
  generator. To be used by `set.seed()`.
  It is recommended to set this argument
  such that the results are reproducible.

Parallel processing is enabled by default,
and a text progress bar (generated by the package `pbapply`)
will be displayed. If `ncores` is omitted,
the number of cores (`ncores`)
to be used will be decided automatically.
Therefore, users usually do not need to
use `ncores`. It is set to 1 here just for
illustration.

In real research with a complicated model and
moderate to large sample size, even with
parallel processing, it may take several minutes,
or even over twenty minutes in some cases.
Nevertheless, this only need to be conducted
once in the workflow of `manymome`.

If bootstrapping takes an appreciable time to
run, it is recommended to save
the output using `saveRDS()` or `save()`:

```{r do_boot_lav_save, eval = FALSE}
### Use saveRDS() ###
# Save the output
saveRDS(boot_out_lavaan, file = "boot_out_lavaan.rds")
# Load the output
boot_out_lavaan <- readRDS("boot_out_lavaan.rds")

### Use save() ###
# Save the output
save(boot_out_lavaan, file = "boot_out_lavaan.RData")
# Load the output
load("boot_out_lavaan.RData")
```

We recommend `readRDS()` although `save()`
is probably a more popular function.

## Using the Output of `do_boot()` in Other Functions of `manymome`

When calling `indirect_effect()` or
`cond_indirect_effects()`, the
argument `boot_out` can be assigned the
output of `do_bout()`. They will then
retrieve he stored bootstrap estimates
to form the bootstrap confidence
intervals, if requested.

```{r indirect_lav}
out_lavaan <- indirect_effect(x = "x",
                              y = "y",
                              m = "m",
                              fit = fit_lavaan,
                              boot_ci = TRUE,
                              boot_out = boot_out_lavaan)
out_lavaan
```

Reusing the bootstrap estimates can ensure that
all analysis with bootstrap confidence intervals
are based on the same set of bootstrap samples.

# Demonstration: `lm()`

## Fit the Model by Several Calls to `lm()`

Suppose we estimate the parameters using
multiple regression. We need to fit two
regression models, one predicts `m` and
the other predicts `y`:

```{r fit_by_lm}
# Fit Models
lm_m <- lm(m ~ x + c1 + c2, dat)
lm_y <- lm(y ~ m + x + c1 + c2, dat)
#
# ###### Regression: Predict m ######
summary(lm_m)
#
# ###### Regression: Predict y ######
#
summary(lm_y)
```

To use `do_boot()`, we first combine the
regression outputs to one object using
`lm2list()`. The output is an
`lm_list`-class object.

```{r lm2list}
fit_lm <- lm2list(lm_m, lm_y)
fit_lm
```

## Generate Bootstrap Estimates

We can now use `do_boot()` as described
above, using the output of `lm2list()`
instead of the output of `lavaan::sem()`:

```{r do_boot_lm}
boot_out_lm <- do_boot(fit = fit_lm,
                       R = 100,
                       seed = 98715,
                       ncores = 1)
```

Like working on the outputs of `lavaan::lavaan()`,
parallel processing is also used by default.
`ncores` is the number of CPU cores to
be used. Because
the output may not be saved, it is
recommended to set the seed of the random
number generation using `seed`, set
to 98715 in the above example. The seed can
be any integer within the range allowed
in R, see `set.seed()`. Setting the seed
ensures that the same `R` set of bootstrap
samples will be generated every time.


## Using the Output of `do_boot()` in Other Functions of `manymome`

When calling `indirect_effect()` or
`cond_indirect_effects()`, we cab set the
argument `boot_out` to the output of
`do_bout()`:

```{r indirect_lm}
out_lm <- indirect_effect(x = "x",
                          y = "y",
                          m = "m",
                          fit = fit_lm,
                          boot_ci = TRUE,
                          boot_out = boot_out_lm)
out_lm
```

# The Structure of the Output

## Models Fitted by `lavaan::sem()`

The output of `do_boot()` in this case
is an object of the class `boot_out`,
which is a list of `R` lists, each with
three elements: `est`, `implied_stats`,
and `ok`.

This is the content of `est` of the first list:

```{r boot_out_est}
boot_out_lavaan[[1]]$est
```

The content is just the first four columns of
the output of `lavaan::parameterEstimates()`.
Note that only fixed and free parameters are used
so other rows, if any, are not used even if present.

This is the content of `implied_stats` of the
first list:

```{r boot_out_implied_stats}
boot_out_lavaan[[1]]$implied_stats
```

It has three elements. `cov` is the implied
variances and covariances of all variables.
If a model has latent variables, they will
be included too. The other elements,
`mean` and `mean_lv`, are the implied
means of the observed variables and
the latent variables (if any), respectively.
They are of zero length if mean structure is
not in the fitted model.

The last element, `ok`, denotes whether
the solution in a bootstrap sample is
admissible or not (determined by
`lavaan::lavInspect()` with
`what = "post.check"`). If not admissible,
it will not be used in forming confidence
intervals.

## Models Fitted by `lm()`

The output of `do_boot()` using the
outputs of `lm()` is identical to
that using the output of `lavaan::sem()`. It is an object of the
class `boot_out`,
which is a list of `R` lists, each with
two elements: `est` and `implied_stats`.

This is the content of `est` of the first list:

```{r boot_out_est_lm}
boot_out_lm[[1]]$est
```

The content is similar in structure
to the output of `lavaan::parameterEstimates()`.
However, the estimates are the estimates
based on `lm()`.

This is the content of `implied_stats` of the
first list:

```{r boot_out_implied_stats_lm}
boot_out_lm[[1]]$implied_stats
```

It has two elements. `cov` is the
variances and covariances of all variables.
Unlike the output based on `lavaan::sem()`,
the content is just the sample variances
and covariances of the variables in each
bootstrap sample, generated using `cov()`.
The other element,
`mean`, stores sample means of all variables
in each bootstrap sample.


# Further Information

For further information on `do_boot()`,
please refer to its help page.

# Reference

Cheung, S. F., & Cheung, S.-H. (2023). *manymome*: An R
package for computing the indirect effects, conditional
effects, and conditional indirect effects, standardized or
unstandardized, and their bootstrap confidence intervals,
in many (though not all) models. *Behavior Research Methods*.
https://doi.org/10.3758/s13428-023-02224-z